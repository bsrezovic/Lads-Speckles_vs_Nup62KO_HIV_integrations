---
title: "Lads"
output: pdf_document
---

```{r setup,echo=F, message=FALSE, warning=FALSE}
library(rtracklayer) # for loading .bw files
library(data.table)
library(ggplot2)
    library(gridExtra)
library(dplyr)
library(stats)
library(mixtools)  # jesus all this for bimodal middle estimation.....
library(DNAcopy)
library(GenomicRanges)
library(biomaRt)
library(nullranges)
library(regioneR)
library(Biostrings)
library(BSgenome.Hsapiens.UCSC.hg19)

knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

**Comparison of Nup62KO integrations to Robson LAD data**

```{r, echo = F}
#Load data
restbw <- import.bw("Jurkat Lamin DAmID RGSE94971_sq77.dpn_smooth_60_R.bw")
actbw <- import.bw("Jurkat Lamin Dam ID A GSE94971_sq77.dpn_smooth_60_A.bw")
df_rest <- as.data.frame(restbw)
df_act <- as.data.frame(actbw)

```

Note: DamID LADs data is raw (only short outliers seem to be filtered out based on file names, with background left in). I re-called the peaks using the same method mentioned in the paper (circualar binary segmentation instead of the hidden markov model that I usally use provided by Maja) to keep consistency with their results. The two methods shouldnt differ much.

```{r, echo = F}
bin = 0.5

pr <- ggplot(df_rest, aes(x=score))+ geom_histogram(binwidth = bin, alpha = 0.4)+theme_minimal()+ggtitle("Resting Lamin DamID scores")
   # geom_line(data = denr, aes(x = x, y = y *length(x) * bin),
   #         color = "blue")+
   # geom_vline(xintercept=midpoint, col = "red")#+
    #geom_vline(xintercept=r_min[36], col = "blue")
pa <- ggplot(df_act, aes(x=score))+ geom_histogram(binwidth = bin, alpha = 0.4)+theme_minimal()+ggtitle("Activated Lamin DamID scores")
    #geom_line(data = dena, aes(x = x, y *length(x) * bin),
    #        color = "blue")+
    #geom_vline(xintercept=midpoint2, col = "red")#+
    #geom_vline(xintercept=a_min[2], col = "blue")#+
    #geom_vline(xintercept=a_min[3], col = "orange")

grid.arrange(pa, pr, ncol=2)
```

```{r, echo = F,messages =F, results = F}
# tunning the DNA copy method
df_act <- as.data.table(df_act)
df_rest <- as.data.table(df_rest)

df_act<- df_act%>%
      mutate(mid = (start + end) / 2)

df_rest<- df_rest%>%
      mutate(mid = (start + end) / 2)
df_act <- as.data.table(df_act)
df_rest <- as.data.table(df_rest)
df2 <- df_act[seqnames %in% c("chr15"),]%>%
      mutate(mid = (start + end) / 2)
cna.object <- CNA(
  genomdat = df2$score,
  chrom    = df2$seqnames,
  maploc   = df2$mid,
  data.type= "logratio"
)
smoothed <- smooth.CNA(cna.object) # this does nothing since its already smooth i think

seg.results <- segment(
  smoothed,
  weights = df2$width,
  verbose = 1
)
segments.df <- seg.results$output

# this should be a perfect segmentation: check for voerlaps just to be sure:
gr <- GRanges(
  seqnames = segments.df$chrom,
  ranges   = IRanges(start = segments.df$loc.start, end = segments.df$loc.end)
)

any(countOverlaps(gr, gr) > 1)  # yay no overlaps, so i guees any overlaps are visual bug/plot error


#thresholds
high_thresh <- quantile(segments.df$seg.mean, 0.575)          # top 5% signal
low_thresh  <- -2 #quantile(segments.df$seg.mean, 0.05)  
```

```{r, eval = F,echo = F}
#Example plot of score distribution on chromosomes and called LADs (by me).
#Paper doesent state exact parameters used, I presumed defaults for the peak calling weighted by fragment width and then #varied the threshold until I got 18,6% of genes (around 3700 in resting and activated) classifed as overlapping LADs as #they have in the paper (for the numbers to match this have to be protein coding genes only. 
#Additionaly they say its genes "within" LADs but the only way to get 18.6% and 3700 at the same time is to count any #overlap between genes and LADs). I also marked segements with segemntation lower than -2 (meaning much higher Dam signal #compared to Dam-fusion).
```
\newpage 
```{r,echo = FALSE,eval = F}


dfg <- segments.df[segments.df$seg.mean >=high_thresh,]
dfb <- segments.df[segments.df$seg.mean <=low_thresh,]

ggplot(df2, aes(x = mid, y = 0, xend = mid, yend = score)) +
  geom_segment(color = "steelblue", alpha = 0.6) +
  geom_segment(
    data = dfb,
    aes(
      x = loc.start,
      xend = loc.end,
      y = -4.3,
      yend = -4.4
    ),
    color = "darkred"
  ) +
  geom_segment(
    data = dfg,
    aes(
      x = loc.start,
      xend = loc.end,
      y = -4.2,
      yend = -4.3
    ),
    color = "green"
  ) +
  facet_wrap(~seqnames, scales = "free_x") +
  labs(x = "Genomic coordinate (bp)", y = "Score") +
  theme_minimal() +
  geom_point(
    aes(x = Inf, y = Inf, color = "Raw score"),
    show.legend = TRUE
  ) +
  geom_point(
    aes(x = Inf, y = Inf, color = "LADs"),
    show.legend = TRUE
  ) +
  geom_point(
    aes(x = Inf, y = Inf, color = "Not LADs"),
    show.legend = TRUE
  ) +
  scale_color_manual(
    name = "",
    values = c(
      "Raw score" = "steelblue",
      "LADs" = "green",
      "Not LADs" = "darkred"
    )
  ) +
  ggtitle("Chr 15") +
  xlab("") +
  ylab("log2(Lamin fusion/Dam)")


  #save df2 to plot all the way down
df2_plot1 <- df2
```

```{r, echo = FALSE, eval = FALSE}
# this just shouldnt run in rmarkdwon as its too long and just run in 
# Ok lets see if the computer can handle actually segmentating the whole thing twice or is this
# a server problem...
segmentator <- function(df2){
    cna.object <- CNA(
      genomdat = df2$score,
      chrom    = df2$seqnames,
      maploc   = df2$mid,
      data.type= "logratio"
    )
    smoothed <- smooth.CNA(cna.object) # this does nothing since its already smooth i think

    seg.results <- segment(
      smoothed,
      weights = df2$width,
      verbose = 1
     )
    segments.df <- seg.results$output
    return(segments.df)
}

seg_r <- segmentator(df_act)
seg_a <- segmentator(df_rest)

saveRDS(list(seg_a,seg_r),"Segments_list.rds")
```

```{r, echo = FALSE, results = FALSE}
# load in the above prepared segmented 
seg_list <- readRDS("Segments_list.rds")
seg_a <- seg_list[1]
seg_r <- seg_list[2]
seg_a <- as.data.table(seg_a)
seg_r <- as.data.table(seg_r)
rm(seg_list)

# Match LADS to genes until you get 18.6% of genes in lads,
# then apply same thinking to determining non lad-ness
# if it turns out the best approach isnt just a vertical line down the
# centre of the bimodal distribution
mart <- useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", host    = 'grch37.ensembl.org')
atts <- c("ensembl_gene_id", "chromosome_name", "start_position", 
          "end_position")
genes <- getBM(attributes = atts, mart = mart,filters = c("transcript_biotype"),
                                                values=c("protein_coding"))
genes <- as.data.table(genes)
chrnames <- paste0("chr",c(c(1:22),"X","Y"))
genes$chromosome_name <- paste0("chr",genes$chromosome_name)
genes <- genes[chromosome_name%in% chrnames,]
setkey(genes, chromosome_name,start_position,end_position )

# simply runnign with all genes gives us 

# calcualted thresholds
high_thresh_a <- quantile(seg_a$seg.mean, 0.575)          # top 5% signal
low_thresh_a  <- -2#quantile(seg_a$seg.mean, 0.05)  

high_thresh_r <- quantile(seg_r$seg.mean, 0.61)          # top 5% signal
low_thresh_r  <- -2#quantile(seg_r$seg.mean, 0.05)  

#Mark and filter by this thresholds
seg_a[,LAD:="Not classified"][seg.mean>=high_thresh_a,LAD:="LAD"][seg.mean<=low_thresh_a,LAD:="Not LAD"]

seg_r[,LAD:="Not classified"][seg.mean>=high_thresh_r,LAD:="LAD"][seg.mean<=low_thresh_r,LAD:="Not LAD"]

setkey(seg_a, chrom, loc.start, loc.end)
setkey(seg_r, chrom, loc.start, loc.end)

gcount <- length(unique(genes$ensembl_gene_id)) 
# theres about 63k genes, some overlap boundries of any lads we make so 
# im gonna go with any sort of overlapp and then see from there
test1 <- foverlaps(genes,seg_a)
num1 <- length(unique(test1[LAD=="LAD" & !is.na(ensembl_gene_id),]$ensembl_gene_id))
num1
num1/gcount*100

test2 <- foverlaps(genes,seg_r)
num2 <- length(unique(test2[LAD=="LAD" & !is.na(ensembl_gene_id),]$ensembl_gene_id))
num2
num2/gcount*100  # rough percentage of genes in lads

seg_a[,LAD_binary:=ifelse(LAD == "LAD","LAD","not LAD")][,type := "Activated"]
seg_r[,LAD_binary:=ifelse(LAD == "LAD","LAD","not LAD")][,type := "Resting"]

lads <- rbind(seg_a,seg_r)
rm(seg_a)
rm(seg_r)

#Load Nup data as well
nups <- read.csv("C:/Users/38598/Desktop/hivint/nup153/Nup_62_2/Nup_all_peaks_together.csv")
nups <- nups[,-1]
nups <- as.data.table(nups)
nups <- nups[!is.na(integration_start)]

rm(test1,test2)
```

# **Overlaps between Nup 62KO integrations and LADs**

```{r,echo = FALSE}

# load the random integration data as well at some point
setkey(lads,chrom, loc.start,loc.end)
setkey(nups,chr_name,integration_start,integration_end)
# complete overlp here, no integrations land in the spaces without LAD data
over <- foverlaps(nups,lads)
# just making things clear
cos <- colnames(over)
cos[9] <- "LAD_celltype"
colnames(over) <- cos  

# jsut keep the same ones
over <- over[cellType == LAD_celltype,]

# Add randm matched controls
real_gr <- GRanges(seqnames = nups$chr_name,strand = nups$strand,
                                ranges = IRanges(start = nups$integration_start,              
                                                        end = nups$integration_end) )
pool <- createRandomRegions(nregions = length(real_gr),
                            genome = BSgenome.Hsapiens.UCSC.hg19)
# lets try both completely random controls, and matched for GC and chromosome etc.
# have to calculaet GC content for this
focal_seq <- getSeq(BSgenome.Hsapiens.UCSC.hg19, real_gr)
pool_seq  <- getSeq(BSgenome.Hsapiens.UCSC.hg19, pool)

# Compute GC proportion
        # without as numveric the ouput is a matrix, so thats why thats there
real_gr$GC <- as.numeric(letterFrequency(focal_seq, "GC", as.prob = TRUE))
pool$GC  <- as.numeric(letterFrequency(pool_seq,  "GC", as.prob = TRUE))

real_gr$chr<- seqnames(real_gr)
pool$chr <- seqnames(pool)

# commented out because it takes a while
#matched <- matchRanges(
#    focal = real_gr,
#    pool  = pool,
#    covar = ~ chr +GC,   # formula: match on chromosome and GC
#    method = "nearest",         # nearest matching
#    replace = TRUE
#)
#RMC_gc_chr <- matched(matched)
# not this doesent keep the width well, just center them as peaks
set.seed(1234)
#saveRDS(RMC_gc_chr,"RMC_covariate.rds")
RMC_gc_chr <- readRDS("RMC_covariate.rds")
# now the fulyy random ones:
RMC_rand <- randomizeRegions(real_gr,
                              genome = BSgenome.Hsapiens.UCSC.hg19,
                              allow.overlaps = FALSE)
# this does keep width for whatever raaason 

#and the old one

sim_bed <- fread("C:/Users/38598/Desktop/hivint/Integrations3/STP_simulated_hg19.clean_R1.bed")
RMC_old <- sim_bed[sample(nrow(sim_bed), nrow(nups)), ]
rm(sim_bed)
# cool # now stick them together i guess


RMC_rand <- as.data.table(RMC_rand)
RMC_rand <- RMC_rand[,c(1,2,3)]
RMC_rand$rmc <- "rand"

RMC_gc_chr <- as.data.table(RMC_gc_chr)
RMC_gc_chr <- RMC_gc_chr[,c(1,2,3)]
RMC_gc_chr$rmc <- "covariate"

RMC_old <- RMC_old[,c(1,2,3)]
RMC_old$rmc <- "old"
colnames(RMC_old) <- colnames(RMC_rand)

RMC <- rbind(RMC_rand,RMC_old,RMC_gc_chr)
rm(RMC_rand,RMC_gc_chr,RMC_old)
# fix widths to 2
RMC <- as.data.table(RMC)
RMC[,start:=end-start%/%2][,end:=start+1]
RMC <- RMC[seqnames %in% chrnames,]
# itnersect with lads
setkey(RMC,seqnames,start,end)

RMC <- foverlaps(RMC,lads)
#not a complete overlap, 2% here drop out due to no lad data, small enough to ignore
RMC <- RMC[!is.na(loc.start),]

RMC[,type2:=paste0(type,"_RMC")]
RMC[,type3:=paste0(type,"_RMC_",rmc)]

```

## Count and proportion plots with and without KO153 / Random matched controls

I'm testing three types of RMCs; the old ones, completely random and covariate that should follow integration data GC content and chromosome distribution

```{r,echo = FALSE}
# Initial simple graphs

# just the count (this is total, includes KO153)
ggplot(over[!group%in%c("Resting_mock","Activated_mock","Resting_KO153","Activated_KO153"),]
, aes(fill=LAD_binary, x=cellType)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+
  geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.3,position = position_stack(reverse = TRUE,vjust = 1)) +
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))
RMC<-RMC[sample(.N,nrow(over)),]

# same as above but with RMC
ggplot(over[!group%in%c("Resting_mock","Activated_mock","Resting_KO153","Activated_KO153"),]
, aes(fill=LAD_binary, x=cellType)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.3,position = position_stack(reverse = TRUE,vjust = 1)) +
  geom_bar(data = RMC,position = position_stack(reverse = TRUE), aes(x = type3, fill = LAD_binary), inherit.aes = F)+
   geom_text(data = RMC,stat = "count", aes(label = ..count..,x = type3, fill = LAD_binary), inherit.aes = F,vjust = -0.3,position = position_stack(reverse = TRUE,vjust = 1))+
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

# This one just to show KO153 is in the dataset
ggplot(over[!group%in%c("Resting_mock","Activated_mock"),]
, aes(fill=LAD_binary, x=group)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.3) +
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

# just KO62
ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=LAD_binary, x=group)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.3) +
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))
# add in the RMC here as well
ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=LAD_binary, x=group)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + 
      geom_bar(position = position_stack(reverse = TRUE),data = RMC, aes(x = type3, fill = LAD_binary), inherit.aes = F)+
            ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+geom_text(stat = "count", aes(label = ..count..),position = position_stack(reverse = TRUE,vjust = 1),
                              vjust = -0.3) +
                                  geom_text(data = RMC,stat = "count", aes(label = ..count..,x = type3, fill = LAD_binary), inherit.aes = F,position = position_stack(reverse = TRUE,vjust = 1),
                                                                  vjust = -0.3) +
                                                                                                    scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
                                                                                                                                        xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

#Add proportion plots

ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=LAD_binary, x=group)) + 
  geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=LAD_binary, x=group)) + 
  geom_bar(position = "fill")+ 
    geom_bar(data = RMC, aes(x = type3, fill = LAD_binary), position = "fill")+
      theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+
        scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
          xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

# below are rations with KO153 included, not needed right now probably

#ggplot(over[!group%in%c("Resting_mock","Activated_mock"),]
#, aes(fill=LAD_binary, x=group)) + 
#  geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All integrations vs LADs")+
#  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
#  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

```
\newpage

Realtive insertion location plots for HIV integration within LADs. Seem relatively uniform, just covariate RMCs behaving weirdly at LAD start sites, which is expected due to GC content of LADs? (covariate RMCs are made to be similar to integration sites in GC content and chromosomal ratios).

```{r,echo = FALSE}
over[,rel_pos:= (integration_start - loc.start)/(loc.end-loc.start)]

ggplot(over[LAD =="LAD" & ! group %in%c("Resting_mock","Activated_mock","Resting_KO153","Activated_KO153")], 
aes(x = rel_pos, fill = group)) +
  geom_histogram(binwidth = 0.05, color = "white", boundary = 0) + # boundry deals with first bin artifacting
  scale_fill_brewer(palette="Blues", direction = 1)+
  labs(x = "Relative position inside LAD",
       y = "Insertion count",
       title = "Distribution of HIV KO62 insertions within LADS") +
  theme_minimal()

# do the sam for RMC
RMC[, rel_pos:=(start - loc.start)/(loc.end-loc.start)]

ggplot(RMC[LAD =="LAD"], 
aes(x = rel_pos, fill = type3)) +
  geom_histogram(binwidth = 0.05, color = "white", boundary = 0) + # boundry deals with first bin artifacting
    scale_fill_brewer(palette="Blues", direction = 1)+
      labs(x = "Relative position inside LAD",
             y = "Insertion count",
                    title = "Distribution of random controls within LADS") +
                      theme_minimal()
```

## Non_genic vs genic inside and outside LADs

```{r,echo  =F}
# add genic status to RmC
setkey(RMC,seqnames,start,end)
RMC <- foverlaps(RMC,genes)
RMC[,isGenic:=ifelse(is.na(ensembl_gene_id),"Nongenic","Genic")]
RMC[,genic_split := paste0("RMC_",isGenic,"_",rmc)]

RMC$group <- "RMC" # add a grouping variable to RMC so that the facet wraps arent fugly
over_s <- over[,c(8,16,21)]
RMC_s <- RMC[,c(11,15,18)]
colnames(RMC_s) <- c("LAD_binary","group","isGenic")
over_ss <- rbind(over_s,RMC_s) 
over_ss[group =="rand",]$group <- "Random RMC"
over_ss[group =="covariate",]$group <- "GC covariate RMC"
over_ss[group =="old",]$group <- "Bedwell RMC"
#counts
pl1 <- ggplot(over[!group%in%c("Resting_mock","Activated_mock"),]
, aes(fill=LAD_binary, x=isGenic)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All integrations vs LADs")+geom_text_repel(stat = "count",position = position_stack(reverse = TRUE), aes(label = ..count..),
                          vjust = 0.9) +facet_wrap(~group)+  coord_cartesian(ylim = c(0, 10000))+
                                                                         scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
                                                                                                                            xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=0.5))

                                                                                                                                       pl1
                                                                                                                                                           #without KO153
pl2 <- ggplot(over[!group%in%c("Resting_mock","Activated_mock","Resting_KO153","Activated_KO153"),]
, aes(fill=LAD_binary, x=isGenic)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+geom_text(stat = "count", vjust = -0.3,position = position_stack(reverse = TRUE,vjust = 1), aes(label = ..count..),
                          vjust = 0.9) +facet_wrap(~group)+  coord_cartesian(ylim = c(0, 10000))+
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
                            xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=0.5))
pl2


pl5 <- ggplot(over_ss[!group%in%c("Resting_mock","Activated_mock","Resting_KO153","Activated_KO153"),]
, aes(fill=LAD_binary, x=isGenic)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations with RMCs vs LADs")+facet_wrap(~group)+  coord_cartesian(ylim = c(0, 10000))+
        geom_text(stat = "count", aes(label = ..count..),
                                vjust = -0.3,position = position_stack(reverse = TRUE,vjust = 1)) +
                                   
                                                                                                                                                                                                scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+                                                                                                                                                                              xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))
pl5
pl6 <- ggplot(over_ss[!group%in%c("Resting_mock","Activated_mock"),]
, aes(fill=LAD_binary, x=isGenic)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All integrations with RMCs vs LADs")+facet_wrap(~group)+  coord_cartesian(ylim = c(0, 10000))+
        geom_text_repel(stat = "count", aes(label = ..count..),
                                position = position_stack(reverse = TRUE)) +
                                   
                                                                                                                                                                                                scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+                                                                                                                                                                              xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))
pl6
                                                    #proportions
pl3 <- ggplot(over[!group%in%c("Resting_mock","Activated_mock"),]
                                                    , aes(fill=LAD_binary, x=isGenic)) + 
                                                      geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All integrations vs LADs")+
                                                        scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+facet_wrap(~group)+
                                                          xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

pl3

pl4 <- ggplot(over[!group%in%c("Resting_mock","Activated_mock","Resting_KO153","Activated_KO153"),]
                                                    , aes(fill=LAD_binary, x=isGenic)) + 
                                                      geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+#ylim(c(0,8000))+
                                                        scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+facet_wrap(~group)+
                                                          xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

pl4
  # here add random matched controls into the mix, thus separating

                                                      #proportions
pl7 <- ggplot(over_ss[!group%in%c("Resting_mock","Activated_mock","Resting_KO153","Activated_KO153"),]
, aes(fill=LAD_binary, x=isGenic)) + facet_wrap(~group)+
  geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations with RMCs vs LADs")+
      scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
        xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 90, vjust = 0, hjust=0.5))
pl7       
pl8 <- ggplot(over_ss[!group%in%c("Resting_mock","Activated_mock"),]
, aes(fill=LAD_binary, x=isGenic)) + facet_wrap(~group)+
  geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All integrations with RMCs vs LADs")+
      scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
        xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 90, vjust = 0, hjust=0.5))
pl8       

pdf("genic_split_full.pdf", height=6, width=8)
pl1
pl2
pl5
pl6
pl3
pl4
pl7
pl8

dev.off()
```
\newpage

## Violin plots of expression for genic integrations and LAD status

## 
[]
```{r,echo = FALSE}
ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),], aes(x = cellType, y = log2(variance_norm_counts+1),fill = LAD_binary)) +
  geom_violin(trim =T) +
    labs(x = "Group", y = "Expression(log2 var norm count)",
           title = "Expression distribution by LAD/Activation") +
             theme_minimal()+ scale_fill_brewer(palette="Blues", direction = 1)+theme(legend.title = element_blank())



ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),], aes(x = group, y = log2(variance_norm_counts+1),fill = group)) +
  geom_violin(trim =T) +
          labs(x = "Group", y = "Expression(log2 var norm count)",
                                   title = "Expression distribution by sample") + facet_wrap(~cellType, scales = "free")+
                    theme_minimal()+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))+
                           scale_x_discrete(drop = TRUE)+
               scale_fill_brewer(palette="Blues", direction = 1)+theme(legend.position = "none")

ggplot(over[!group%in%c("Resting_mock","Activated_mock"),], aes(x = group, y = log2(variance_norm_counts+1),fill = group)) +
  geom_violin(trim =T) +
          labs(x = "Group", y = "Expression(log2 var norm count)",
                                   title = "Expression distribution by sample") + facet_wrap(~cellType, scales = "free")+
                    theme_minimal()+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))+
                           scale_x_discrete(drop = TRUE)+
               scale_fill_brewer(palette="Blues", direction = 1)+theme(legend.position = "none")


ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),], aes(x = group, y = log2(variance_norm_counts+1),fill = LAD_binary)) +
  geom_violin(trim =T) +
            labs(x = "Group", y = "Expression(log2 var norm count)",
                                               title = "Expression distribution by sample and LAD") + facet_wrap(~cellType, scales = "free")+
                       theme_minimal()+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))+
        scale_x_discrete(drop = TRUE)  +
         scale_fill_brewer(palette="Blues", direction = 1)+theme(legend.title = element_blank()) 

#adding RMCs to this is lemon difficult
# have to cross it with all expression data and thats below
#  continued below after expression dataset load
```

### Same as above but added RMCs (GC cov only for spacing reasons. Generally look the same) If plot doesent specify experimental samples that means mock and KO153 are excluded:

```{r, echo = FALSE}
# get all the expressioin data
normalized_counts <- read.csv("C:/Users/38598/Desktop/hivint/nup153/Nup_62_2/cd4ACTvsREST_VSTcounts.csv")

# good now we have all genes, intersect this with LADS and genic integrations
# First split by Act/Rest, then paste back together
normalized_counts <- as.data.table(normalized_counts)
normcounts2 <- normalized_counts
normalized_counts$type <- "Resting"
normcounts2$type <- "Activated"
normalized_counts$variance_norm_counts <- normalized_counts$resting
normcounts2$variance_norm_counts <- normcounts2$activated

# we also need  Non integration LADs. so we need to cross lads with genes again
lad_genes <- foverlaps(lads[LAD_binary == "LAD"],genes)

# count it all up
normalized_counts[,Integration:=ifelse(gene_name %in% nups[cellType =="Resting" & isGenic =="Genic",]$ensembl_gene_id,
                                      "Integration present","No integration")][,LAD_status:=ifelse(gene_name %in% lad_genes[type =="Resting" & LAD_binary =="LAD",]$ensembl_gene_id,"in LAD","not in LAD")]

normcounts2[,Integration:=ifelse(gene_name %in% nups[cellType =="Activated" & isGenic =="Genic",]$ensembl_gene_id,
                                      "Integration present","No integration")][,LAD_status:=ifelse(gene_name %in% lad_genes[type =="Activated" & LAD_binary =="LAD",]$ensembl_gene_id,"in LAD","not in LAD")]

norms <- rbind(normalized_counts,normcounts2)

#Slam this into the RMC data
genic_RMC <- foverlaps(RMC,genes)
genic_RMC <- genic_RMC[!is.na(ensembl_gene_id),]

genic_RMC2 <- merge(genic_RMC, norms,by.x = c("ensembl_gene_id","type"),by.y =c("gene_name","type"))
#good that worked 

ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),], aes(x = cellType, y = log2(variance_norm_counts+1),fill = LAD_binary)) +
  geom_violin(trim =T, width= 0.7) +
              labs(x = "Group", y = "Expression(log2 var norm count)",
                                                             title = "Expression distribution by group plus RMCs") +
                                                                                                                      theme_minimal()+ scale_fill_brewer(palette="Blues", direction = 1)+
                                                                                                                                                                                    geom_violin(width = 0.7, data = genic_RMC2[type3 %in%c("Activated_RMC_covariate","Resting_RMC_covariate"),], aes(x = type2, y = log2(variance_norm_counts+1),fill = LAD_binary),trim = T)+theme(legend.title = element_blank())


genic_RMC2$cellType <- genic_RMC2$type # need equal names for faceting variable
ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),], aes(x = group, y = log2(variance_norm_counts+1),fill = group)) +
  geom_violin(trim =T,width = 0.5) +
    geom_violin(width = 0.5, data = genic_RMC2[type3 %in%c("Activated_RMC_covariate","Resting_RMC_covariate"),], aes(x = type2, y = log2(variance_norm_counts+1),fill = type2),trim = T)+
              labs(x = "Group", y = "Expression(log2 var norm count)",
                                                 title = "Expression distribution by sample") + facet_wrap(~cellType, scales = "free")+
                                                                     theme_minimal()+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))+
                                                                                                scale_x_discrete(drop = TRUE)+
                                                                                                               scale_fill_brewer(palette="Blues", direction = 1)+theme(legend.position = "none")


ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),], aes(x = group, y = log2(variance_norm_counts+1),fill = LAD_binary)) +
  geom_violin(trim =T) +
   geom_violin(width = 0.5, data = genic_RMC2[type3 %in%c("Activated_RMC_covariate","Resting_RMC_covariate"),], aes(x = type2, y = log2(variance_norm_counts+1),fill = LAD_binary),trim = T)+
            labs(x = "Group", y = "Expression(log2 var norm count)",
                                               title = "Expression distribution by sample and LAD") + facet_wrap(~cellType, scales = "free")+
                       theme_minimal()+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))+
        scale_x_discrete(drop = TRUE)  +
         scale_fill_brewer(palette="Blues", direction = 1)+theme(legend.title = element_blank()) 

```

## Comparison of all genes we have expression data for, by LAD/integration status

```{r, echo = FALSE}
ggplot(norms, aes(x = type, y = log2(variance_norm_counts+1),fill = LAD_status)) +
  geom_violin(trim =T) +
                labs(x = "Group", y = "Expression(log2 var norm count)",
                                                                             title = "Expression distribution") + facet_wrap(~Integration, scales = "free")+
                                                                                                                                                                 theme_minimal()+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))+
                                                                                                                                                                                                                                                             scale_x_discrete(drop = TRUE)  +
                                                                                                                                                                                                                                                                                                                                                                  scale_fill_brewer(palette="Blues", direction = 1)  
```

# Comparison with DamID data from Belmont

```{r, include = FALSE}
library(easylift)
# first chech their K562 Lamin data to see (expect 85% match?)
#blads <- fread("belmont_data/belmont_lads.bed")
#blads[,width:=V3-V2]
#colnames(blads) <- c("chrom","start","end","width")
chain_file <- "hg38ToHg19.over.chain"
chain <- import.chain(chain_file)
#use ucsc to lift over as well?
blads2 <- fread("belmont_data/belmont_lads_lifted.bed")
blads2[,width:=V3-V2]
colnames(blads2) <- c("chrom","start","end","name","count","width")

# is this the TSA seq peaks for LADS???
blads3 <- fread("belmont_data/K562_pwv_fiLAD.bed")

#total data?
tots <- fread("belmont_data/All_Data100kb.tsv")
# separate our target cells
tots <- tots[cell.name == "K562",]
# save this as .bed
tots <- tots[,-1]
tots$index <- 1:nrow(tots)  # get a unique ide to handle multi
tot_gr <- makeGRangesFromDataFrame(tots, keep.extra.columns = TRUE)
genome(tot_gr) <- "38"
gr_hg19 <- easylift(tot_gr,
                    to = "hg19",
                    chain = "hg38ToHg19.over.chain")

tots19 <- as.data.table(gr_hg19)
# keep the widestm multi aligns
tots19 <- tots19 %>%
  group_by(index) %>%
  slice_max(width) %>%
  as.data.table()

setkey(tots19,seqnames, start,end)
```

LAD overlap Belmont vs Robson (both DamID) The Robson method (atleast the way I tried to reconstruct it) of calling LADs from DamID peaks using circular binary segmentation results in more numerous, smaller LADs being called than in Belmon, where they bin the genome and just calculate a cumulative fold change od LmnB1-Dam over Dam for the bins, resulting in wider calls. The results are pretty similar: around 80% of Robson Jurkat LADs are overlapping with Belmont K562 LADs, and around 90% of Belmont LADs overlap Robson LADs. As expected more integrations fall in the bigger Belmont LADs, but the various ratios between groups remain the same:

```{r,echo = FALSE, results = F}

gr1 <- makeGRangesFromDataFrame(lads, keep.extra.columns = TRUE)
gr1 <- gr1[gr1$LAD_binary == "LAD"]
# this is both activated and Resting so presumably some things are being counted twice
gr2 <- makeGRangesFromDataFrame(tots19[lads == T,], keep.extra.columns = TRUE)

length(gr1)
length(gr2)

# liftover back to hg19 for the new data
#chain <- import.chain("hg38ToHg19.over.chain")

#lift <- liftOver(gr2, chain)
#gr2_hg19 <- unlist(lift)
#length(gr2_hg19)
# put it back into the data.table before i forget
#blads <- as.data.table(gr2_hg19)

# confirm percentage overlap

hits <- findOverlaps(gr1, gr2, type ="within")
# test the proces from fig7.Rmd
#hits <- findOverlaps(gr1, hff[hff$lad_status=="LADs"], type ="any")

# this is how many mine have belmont in them (meaning any overlap)
sum(1:length(gr1) %in%unique(queryHits(hits)) ) / length(gr1) * 100
sum( 1:length(gr2) %in%unique(subjectHits(hits))) / length(gr2) * 100


# split resting and active just for lols
gr1r <- gr1[gr1$type == "Resting"]
gr1a <- gr1[gr1$type == "Activated"]

hits <- findOverlaps(gr1a, gr2, type ="any")
sum(1:length(gr1a) %in%unique(queryHits(hits)) ) / length(gr1a) * 100
sum( 1:length(gr2) %in%unique(subjectHits(hits))) / length(gr2) * 100

hits <- findOverlaps(gr1r, gr2, type ="any")
sum(1:length(gr1r) %in%unique(queryHits(hits)) ) / length(gr1r) * 100
sum( 1:length(gr2) %in%unique(subjectHits(hits))) / length(gr2) * 100


gr1_overlap  <- gr1 %over% gr2
gr2_overlap  <- gr2 %over% gr1

# percentages
pct1 <- sum(gr1_overlap) / length(gr1) * 100
pct2 <- sum(gr2_overlap) / length(gr2) * 100

df <- data.frame(
  Set = c("gr1", "gr2"),
  PercentOverlap = c(pct1, pct2)
)



df2 <- data.frame(
  Set = rep(c("Robson LAD","Belmon LAD"), each = 2),
  Category = rep(c("Overlap","No Overlap"), 2),
  Count = c(sum(gr1_overlap), length(gr1)-sum(gr1_overlap),
            sum(gr2_overlap), length(gr2)-sum(gr2_overlap))
)

ggplot(df2, aes(x = Set, y = Count, fill = Category)) +
  geom_col(position="fill") +
  ylab("Proportion") +ggtitle("Comparisn of Belmont and Robson LADs")+
  scale_y_continuous(labels = scales::percent) +
  theme_minimal() + 
         scale_fill_brewer(palette="Blues", direction = -1)+theme(legend.title = element_blank()) 


```

```{r,echo =FALSE}
#repeat some graphs just to get the point across

setkey(nups,chr_name,integration_start,integration_end)
# complete overlp here, no integrations land in the spaces without LAD data
over2 <- foverlaps(nups,tots19)

# just making things clear
over2$LAD_binary <- "LAD"
over2[is.na(start) | !lads,LAD_binary:="not LAD"]


# just the count (this is total, without mock and K153)
ggplot(over2[!group%in%c("Resting_mock","Activated_mock","Resting_KO153","Activated_KO153"),]
, aes(fill=LAD_binary, x=cellType)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs Belmont LADs")+
  geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.3,position = position_stack(reverse = TRUE,vjust = 1)) +
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

# split up by sample
ggplot(over2[!group%in%c("Resting_mock","Activated_mock"),]
, aes(fill=LAD_binary, x=group)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs Belmont LADs")+geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.3,position = position_stack(reverse = TRUE,vjust = 1))  +
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))


p1 <- ggplot(over2[!group%in%c("Resting_mock","Activated_mock"),]
, aes(fill=LAD_binary, x=group)) + 
  geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs Belmont LADs")+#geom_text(stat = "count", aes(label = ..count..),
           # vjust = -0.3,position = position_stack(reverse = TRUE,vjust = 1))  +
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))
p1
```

### Cross comparison of integrations in Belmont and Robson LAD data

```{r,echo = FALSE,results = F}
# get a new table to cross reference all this 
# modified so that we dont end up with something unrecognisable as columns in a huge table
# 1. add unique id to nups table
nups$uid <- 1:nrow(nups)
# make sure there are no self -overlaps here
# hmm are these things self overlapping?

# ofcourse the Resting and Activatd for Robson LADS do overlap, deal with that as we go
hits <- findOverlaps(gr1[gr1$type =="Resting"],gr1[gr1$type=="Resting"])
hits[queryHits(hits) != subjectHits(hits)]

gr2 <- reduce(gr2)# ok due to the hg19->hg38 diffs we have reinduced some overlaps here
hits <- findOverlaps(gr2,gr2)
hits[queryHits(hits) != subjectHits(hits)]
 


lad1 <- lads[LAD_binary == "LAD",c(2,3,4)]
lad2 <- as.data.table(gr2)
lad2 <- lad2[,c(1,2,3)]
lad1$set <- "Robson"
lad2$set <- "Belmont"
lads_total <- rbind(lad1,lad2,use.names=FALSE)
colnames(lads_total) <- c("chrom","start","end","set")
setkey(lads_total,chrom,start,end)
rm(lad1,lad2)

over3 <- foverlaps(nups,lads_total)

over3[,suma:=.N,by = c("uid","cellType")] # if its in more than 2 then its bridging 2 gaps basically

over3[is.na(set), set:="Neither"]
over3[suma>1,set:="Both"]
over3[set == "Robson",set:="Only Robson"]
over3[set == "Belmont",set:="Only Belmont"]

# simple bar graph to showcase this somehow
ggplot(over3, aes(x = set, fill = set)) +
  geom_bar() +
  theme_minimal() +ggtitle("Number of HIV integrations in LAD sets")+
  xlab("") +scale_fill_brewer(palette="Blues", direction = 1)+
  ylab("") + theme(legend.position="none")

rm(df,df2,gr1,gr2,gr1r,gr1a,hits,gr1_overlap,gr2_overlap)
```

\newpage

Belmont TAS-seq speckle data (SPAD peaks called on 25kb segments) These are pretty scarce datapoints so theres not many integrations in them.

```{r,echo = FALSE}
# load in the presumed speckle associated data

#this is for type of spaclƒçe asssocoation, big table is for extra info
spad <- fread("belmont_data/K562_TypeI_II_peak.bed")
spad <- spad[,c(1,2,3,4)]
colnames(spad) <- c("seqnames","start","end","type")
spad$index <- 1:nrow(spad)
spad_gr <- makeGRangesFromDataFrame(spad, keep.extra.columns = TRUE)
genome(spad_gr) <- "38"
spad_hg19 <- easylift(spad_gr,
                    to = "hg19",
                    chain = "hg38ToHg19.over.chain")

spad <- as.data.table(spad_hg19)
# keep the widestm multi aligns
spad <- spad %>%
  group_by(index) %>%
  slice_max(width) %>%
  as.data.table()


# type 1 and 2 peaks explained in Belmont
setkey(spad,seqnames,start,end)

over4 <- foverlaps(nups,spad)
over4[is.na(type),type:="Not in SPAD"]

ggplot(over4[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=type, x=group)) + 
  geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs SPAD peaks")+
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

# comapre just the two types
ggplot(over4[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153") & type !="Not in SPAD",]
, aes(fill=type, x=group)) + 
  geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs SPAD peaks")+
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))
# is this significan?



# add in RMCs here as well
RMC2 <- foverlaps(RMC,spad)
RMC2[is.na(type),type:="Not in SPAD"]

# test out the same for
ggplot(over4[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153")& type !="Not in SPAD",]
, aes(fill=type, x=group)) + 
  geom_bar(position = "fill")+ 
    geom_bar(data = RMC2[type !="Not in SPAD",], aes(x = type3, fill = type), position = "fill")+
      theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+
        scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
          xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

rm(over4,RMC2)
```
\newpage

Integrations vs Belmont SPIN classification of intranuclear localization (combined use of TAS,DamID and Hi-C) This classification method widens the Spackle associated domains compared to the raw peak to integration overlap above. (NANs are regions that are present but not classified in Belmont data).

```{r,echo =FALSE,results =F}
# big table
table(tots19$spin,tots19$lads)
 blue_palette <- colorRampPalette(c("azure", "dodgerblue4", "navy"))(11)
over2[is.na(spin),spin:="Not in Belmont data"]

ggplot(over2[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=spin, x=cellType)) + 
  geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs SPIN states")+
    scale_fill_brewer(palette="RdBu", direction = 1)+ theme(axis.ticks.y = element_blank())+
      xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

p2 <- ggplot(over2[!group%in%c("Resting_mock","Activated_mock"),]
, aes(fill=spin, x=group)) + 
  geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs SPIN states")+
    scale_fill_brewer(palette="RdBu", direction = 1)+ theme(axis.ticks.y = element_blank())+
      xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))
p2

# add RMCs
RMC3 <- foverlaps(RMC,tots19)
RMC3[is.na(spin),spin:="Not in Belmont data"]

ggplot(over2[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=spin, x=cellType)) + 
  geom_bar(position = "fill")+
  geom_bar(data = RMC3[], aes(x = type3, fill = spin), position = "fill")+
   theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs SPIN states")+
    scale_fill_brewer(palette="RdBu", direction = 1)+ theme(axis.ticks.y = element_blank())+
      xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

ggplot(over2[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=spin, x=group)) + 
  geom_bar(position = "fill")+
  geom_bar(data = RMC3[], aes(x = type3, fill = spin), position = "fill")+
   theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs SPIN states")+
    scale_fill_brewer(palette="RdBu", direction = 1)+ theme(axis.ticks.y = element_blank())+
      xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

```

Why all the differences when using CG content covariate RMCs compared to fully random points or the bedwell method of creating a pool of sonication sized fragments etc.? - Belmont Spackle SPIN domains have on average 50% GC - integrations and therefore covariates based on GC content have around 44% - For example interior_Act1 SPIN domain has 45% GC - Fully random points gives around 38% GC Possible conclusion: Controlling for GC content in RMC creation here causes avoidance or bias to/agianst some SPIN domains, if there is more/less integrations in Spackle or LAD domains it is not due to GC content alone.

```{r,echo = FALSE, eval = FALSE}
# get CG frequencies for LADs, SPINs and for NUP integrations
np <- nups[,c(2,3,4)]
colnames(np) <- c("seqnames","start","end")
nups_gr <- makeGRangesFromDataFrame(np)
nups_ia1 <- makeGRangesFromDataFrame(tots19[spin == "Interior_Act1", ])
nups_sp <- makeGRangesFromDataFrame(tots19[spin == "Speckle",])
nups_lam <- makeGRangesFromDataFrame(tots19[spin == "Lamina",])
# add also the random ones
rand <- makeGRangesFromDataFrame(RMC[rmc == "old",c(1,10,11)])

nups_seq<- getSeq(BSgenome.Hsapiens.UCSC.hg19, nups_gr)
intact1_seq<- getSeq(BSgenome.Hsapiens.UCSC.hg19, nups_ia1)
spackle_seq<- getSeq(BSgenome.Hsapiens.UCSC.hg19, nups_sp)
lam <- getSeq(BSgenome.Hsapiens.UCSC.hg19, nups_lam)
rand_seq<- getSeq(BSgenome.Hsapiens.UCSC.hg19, rand)

gc_content_rand <- mean(rowSums(alphabetFrequency(rand_seq)[, c("G", "C")]) / width(rand_seq)) * 100
gc_content_ints <- mean(rowSums(alphabetFrequency(nups_seq)[, c("G", "C")]) / width(nups_seq)) * 100
gc_content_inta1 <- mean(rowSums(alphabetFrequency(intact1_seq)[, c("G", "C")]) / width(intact1_seq)) * 100
gc_content_spa <- mean(rowSums(alphabetFrequency(spackle_seq)[, c("G", "C")]) / width(spackle_seq)) * 100
 mean(rowSums(alphabetFrequency(lam)[, c("G", "C")]) / width(lam)) * 100

gc_content_ints
gc_content_inta1
gc_content_spa 
gc_content_rand
```

### Unique vs in common genic integrations

First split by being in both Activated and Resting cells:

```{r,echo = FALSE}
ngenic <- nups[isGenic == "Genic"]
ngenic <- ngenic[!group%in%c("Resting_mock","Activated_mock"),]
# separate by both group and cell type
ngenic[, `:=`(
  count_total = .N,
  in_both_classes = uniqueN(cellType) >= 2
), by = ensembl_gene_id][
  , count_in_celltype := .N, by = .(ensembl_gene_id, cellType)
][
  , count_in_group := .N, by = .(ensembl_gene_id, group)
][
  ,in_all_groups := uniqueN(group) >= 4, by = ensembl_gene_id
]

setkey(ngenic,chr_name,integration_start,integration_end)
# complete overlp here, no integrations land in the spaces without LAD data
over5 <- foverlaps(ngenic,tots19)
over5[is.na(spin),spin:="Not in Belmont data"]



ggplot(over5[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=spin, x=cellType)) + 
  geom_bar(stat = "count",position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All genic integrations vs SPIN states, \n split by being unique or in common to cell types")+ facet_wrap(~in_both_classes)+
      scale_fill_brewer(palette="RdBu", direction = 1)+ theme(axis.ticks.y = element_blank())+
            xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

p3 <- ggplot(over5[!group%in%c("Resting_mock","Activated_mock"),]
, aes(fill=spin, x=group)) + 
  geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All genic integrations vs SPIN states, \n split by being unique or in common to cell types")+facet_wrap(~in_both_classes)+
    scale_fill_brewer(palette="RdBu", direction = 1)+ theme(axis.ticks.y = element_blank())+
      xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

p3
```
\newpage
Split on the basis of being in all 4 groups:

```{r,echo = FALSE}
ggplot(over5[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=spin, x=cellType)) + 
  geom_bar(stat = "count",position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All genic integrations vs SPIN states, \n split by being present in all 4 groups")+ facet_wrap(~in_all_groups)+
      scale_fill_brewer(palette="RdBu", direction = 1)+ theme(axis.ticks.y = element_blank())+
            xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

p4 <- ggplot(over5[!group%in%c("Resting_mock","Activated_mock"),]
, aes(fill=spin, x=group)) + 
  geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All genic integrations vs SPIN states, \n split by being present in all 4 groups")+facet_wrap(~in_all_groups)+
    scale_fill_brewer(palette="RdBu", direction = 1)+ theme(axis.ticks.y = element_blank())+
      xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))
```
\newpage

Divided based on number of integrations in same gene Definite skew towards Speckles in genes with higher number of repeat integrations and away from Lm1 When compared to RMCs biggest outlier is Lamina, logicaly because it is the largest group in the Belmont SPIN dataset by number of segments.

```{r,echo = FALSE,results = F}
# make some splits on total count
over5[,totals:= ifelse(count_total <2,"unique (4549)",
                ifelse(count_total >=2 & count_total <10, "2-10 (20405)",
                ifelse(count_total <20 & count_total >=10,">10 (5684)",
                ifelse(count_total >=20 & count_total < 40,">=20 (2785)",
                ifelse(count_total >=40, ">=40 (813)","error")) )))]

ggplot(over5[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=spin, x=cellType)) + 
  geom_bar(stat = "count",position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All genic integrations vs SPIN states, \n split by repeated number of integrations in same gene")+ facet_wrap(~totals)+
      scale_fill_brewer(palette="RdBu", direction = 1)+ theme(axis.ticks.y = element_blank())+
            xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))


p5 <- ggplot(over5[!group%in%c("Resting_mock","Activated_mock"),]
, aes(fill=spin, x=group)) + 
  geom_bar(stat = "count",position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All genic integrations vs SPIN states, \n split by repeated number of integrations in same gene")+ facet_wrap(~totals)+
      scale_fill_brewer(palette="RdBu", direction = 1)+ theme(axis.ticks.y = element_blank())+
            xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 90, vjust = 0.8, hjust=0.5))
p5
over5[,totals_by_group:= ifelse(count_in_group <2,"unique",
                ifelse(count_in_group >=2 & count_in_group <5, "2-5",
                ifelse(count_in_group <11 & count_in_group >=5,"5-10",
                ifelse(count_in_group >=10 & count_in_group < 15,"10-15",
                ifelse(count_in_group >=15, ">=15","error")) )))]

ggplot(over5[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=spin, x=group)) + 
  geom_bar(stat = "count",position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All genic integrations vs SPIN states, \n split by repeated number of integrations in same gene within that group")+ facet_wrap(~totals_by_group)+
        scale_fill_brewer(palette="RdBu", direction = 1)+ theme(axis.ticks.y = element_blank())+
                    xlab("")+ylab("")+ theme(axis.text.x = element_text(angle =90, vjust = 0.8, hjust=0.5))


# different type of graph without groupping them together maybe with whiskers as well
ggplot(over5[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=spin, x=group, y= (count_total))) + #coord_cartesian(ylim = quantile(over5$count_total, c(0.05, 0.95)))+
  geom_boxplot()+ theme_minimal() + ylab("Number of integrations in gene")+#ggtitle("All genic integrations vs SPIN states, \n split by repeated number of integrations in same gene within that group")+ #facet_wrap(~totals_by_group)+
                scale_fill_brewer(palette="RdBu", direction = 1)+ theme(axis.ticks.y = element_blank())+
                                                                        xlab("")+ theme(axis.text.x = element_text(angle = 90, vjust = 0.8, hjust=0.5))
 ggplot(over5[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=spin, x=group, y= log(count_total))) + #coord_cartesian(ylim = quantile(over5$count_total, c(0.05, 0.95)))+
  geom_boxplot()+ theme_minimal() + ylab("log( Number of integrations in gene )")+#ggtitle("All genic integrations vs SPIN states, \n split by repeated number of integrations in same gene within that group")+ #facet_wrap(~totals_by_group)+
                scale_fill_brewer(palette="RdBu", direction = 1)+ theme(axis.ticks.y = element_blank())+
                                                                        xlab("")+ theme(axis.text.x = element_text(angle = 90, vjust = 0.8, hjust=0.5))                                                                       

# a lil two way anova
anchovy <- aov(count_total ~ spin * group, data =over5[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),] )
summary(anchovy)
# anova not fully appropriate (data non normal - count data), but large enough that it porbably doesent matter

# add in our RMCs?
RMCx <- foverlaps(RMC,tots19)
RMCx[is.na(spin),spin:="Not in Belmont data"]
setkey(RMCx,seqnames, i.start,i.end)
RMCx <- foverlaps(RMCx,genes)
RMCx <- RMCx[!is.na(ensembl_gene_id),]
# reduce numerousnerss
RMCx <- RMCx[sample(.N,nrow(over5),replace = T),]
RMCx[,count_total := .N, by = ensembl_gene_id]

ggplot(over5[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=spin, x=cellType, y= log(count_total))) + #coord_cartesian(ylim = quantile(over5$count_total, c(0.05, 0.95)))+
  geom_boxplot()+
    geom_boxplot(data = RMCx[rmc == "old",], aes(fill = spin,y = log(count_total), x= type2))+
       theme_minimal() + ylab("log (Number of integrations in gene)")+ggtitle("All genic integrations vs SPIN states, \n split by repeated number of integrations in same gene within that group")+ #facet_wrap(~totals_by_group)+
                         scale_fill_brewer(palette="RdBu", direction = 1)+ theme(axis.ticks.y = element_blank())+
                                                                                                                   xlab("")+ theme(axis.text.x = element_text(angle = 90, vjust = 0.8, hjust=0.5))
                                                                                                         
```
\newpage 

## Comparison of integration patterns in both sets of data with our expression data. Our expression values vs genic integration counts and spin classification by count and mean count of number of integrations into the same gene

```{r, echo = FALSE}
 ggplot(over5[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
  , aes( y=variance_norm_counts, x= count_total)) + #coord_cartesian(ylim = quantile(over5$count_total, c(0.05, 0.95)))+
   geom_bin2d() +
     facet_grid(spin ~ group)+xlab("Number of genic integrations")+ylab("Variance normalized counts")

# same thing but mean
summary_df <- over5[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),] %>%
  group_by(spin,group,variance_norm_counts) %>%           # group by your categories
  summarise(mean_count = mean(count_total),   # calculate mean of numeric var
            .groups = "drop")  

ggplot(summary_df, aes(y = variance_norm_counts, x = mean_count,
                       color = mean_count)) +
  geom_point(size = 3, alpha = 0.8)+ facet_grid(spin~ group)
             
```


```{r}
pdf("genic_split.pdf", height=6, width=8)
pl2

dev.off()
```