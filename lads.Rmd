---
title: "Lads"
output: pdf_document
---

```{r setup,echo=F, message=FALSE, warning=FALSE}
library(rtracklayer) # for loading .bw files
library(data.table)
library(ggplot2)
    library(gridExtra)
library(dplyr)
library(stats)
library(mixtools)  # jesus all this for bimodal middle estimation.....
library(DNAcopy)
library(GenomicRanges)
library(biomaRt)
library(nullranges)
library(regioneR)
library(Biostrings)
library(BSgenome.Hsapiens.UCSC.hg19)
```

## Comparison of Nup62KO integrations to Lads

```{r, echo = F}
#Load data
restbw <- import.bw("Jurkat Lamin DAmID RGSE94971_sq77.dpn_smooth_60_R.bw")
actbw <- import.bw("Jurkat Lamin Dam ID A GSE94971_sq77.dpn_smooth_60_A.bw")
df_rest <- as.data.frame(restbw)
df_act <- as.data.frame(actbw)

```

Note: DamID lads data is raw (only short outliers seem to be filtered out, with background left in). I re-called the peaks using the same method mentioned in the paper (circualar binary segmentation instead of the hidden markov model that I usally use provided by Maja).

```{r, echo = F}
bin = 0.5

pr <- ggplot(df_rest, aes(x=score))+ geom_histogram(binwidth = bin, alpha = 0.4)+theme_minimal()+ggtitle("Resting Lamin DamID scores")
   # geom_line(data = denr, aes(x = x, y = y *length(x) * bin),
   #         color = "blue")+
   # geom_vline(xintercept=midpoint, col = "red")#+
    #geom_vline(xintercept=r_min[36], col = "blue")
pa <- ggplot(df_act, aes(x=score))+ geom_histogram(binwidth = bin, alpha = 0.4)+theme_minimal()+ggtitle("Activated Lamin DamID scores")
    #geom_line(data = dena, aes(x = x, y *length(x) * bin),
    #        color = "blue")+
    #geom_vline(xintercept=midpoint2, col = "red")#+
    #geom_vline(xintercept=a_min[2], col = "blue")#+
    #geom_vline(xintercept=a_min[3], col = "orange")

grid.arrange(pa, pr, ncol=2)
```

```{r, echo = F}
# tunning the DNA copy method
df_act <- as.data.table(df_act)
df_rest <- as.data.table(df_rest)

df_act<- df_act%>%
      mutate(mid = (start + end) / 2)

df_rest<- df_rest%>%
      mutate(mid = (start + end) / 2)
df_act <- as.data.table(df_act)
df_rest <- as.data.table(df_rest)
df2 <- df_act[seqnames %in% c("chr15"),]%>%
      mutate(mid = (start + end) / 2)
cna.object <- CNA(
  genomdat = df2$score,
  chrom    = df2$seqnames,
  maploc   = df2$mid,
  data.type= "logratio"
)
smoothed <- smooth.CNA(cna.object) # this does nothing since its already smooth i think

seg.results <- segment(
  smoothed,
  weights = df2$width,
  verbose = 1
)
segments.df <- seg.results$output

# this should be a perfect segmentation: check for voerlaps just to be sure:
gr <- GRanges(
  seqnames = segments.df$chrom,
  ranges   = IRanges(start = segments.df$loc.start, end = segments.df$loc.end)
)

any(countOverlaps(gr, gr) > 1)  # yay no overlaps, so i guees any overlaps are visual bug/plot error


#thresholds
high_thresh <- quantile(segments.df$seg.mean, 0.575)          # top 5% signal
low_thresh  <- -2 #quantile(segments.df$seg.mean, 0.05)  
```

Example plot of score distribution on chromosomes and called LADs (by me).
Paper doesent state exact parameters used, I presumed defaults for the peak calling weighted by fragment width and then varied the threshold until I got 18,6% of genes (around 3700 in resting and activated) classifed as overlapping LADs as they have in the paper (for the numbers to match this have to be protein coding genes only. 
Additionaly they say its genes "within" LADs but the only way to get 18.6% and 3700 at the same time is to count any overlap between genes and LADs). I also marked segements with segemntation lower than -2 (meaning much higher Dam signal compared to Dam-fusion).

```{r,echo = FALSE}


dfg <- segments.df[segments.df$seg.mean >=high_thresh,]
dfb <- segments.df[segments.df$seg.mean <=low_thresh,]

ggplot(df2, aes(x = mid, y = 0, xend = mid, yend = score)) +
     geom_segment(color = "steelblue", alpha = 0.6) +
              # segemnts that ae def not LADS
                            geom_segment(
                                                   data = dfb,
                                                                                       aes(
                                                                                         x    = loc.start,
                                                                                           xend = loc.end,
                                                                                                     y    = - 4.3,     # lower the bar slightly
                                                                                                               yend = - 4.4      # same y for horizontal
                                                                                                                         ), color = "darkred"
                                                                                                                          )+
                                                                                                                           # probably lads?
                                                                                                                              geom_segment(
                                                                                                                                  data = dfg,
                                                                                                                                   aes(
                                                                                                                                     x  = loc.start,
                                                                                                                                     xend  = loc.end,
                                                                                                                                      y = -4.2,
                                                                                                                                      yend=-4.3),
                                                                                                                                       color = "green") +
                                                                                                                                        facet_wrap(~ seqnames, scales = "free_x") +
                                                                                                                                         labs(x = "Genomic coordinate (bp)", y = "Score") +
                                                                                                                                         theme_minimal()+
                                                                                                                                          geom_point(
                                                                                                                                          aes(x = Inf, y = Inf, color = "Raw score"),
                                                                                                                                          show.legend = TRUE
                                                                                                                                           ) +
                                                                                                                                           geom_point(
                                                                                                                                           aes(x = Inf, y = Inf, color = "LADs"),
                                                                                                                                           show.legend = TRUE
                                                                                                                                            ) +
                                                                                                                                             geom_point(
                                                                                                                                              aes(x = Inf, y = Inf, color = "Not LADs"),
                                                                                                                                              show.legend = TRUE
                                                                                                                                              ) +
                                                                                                                                               scale_color_manual(
                                                                                                                                                name   = "",
                                                                                                                                                 values = c(
                                                                                                                                                 "Raw score"     = "steelblue",
                                                                                                                                                  "LADs"  = "green",
                                                                                                                                                   "Not LADs" = "darkred"
                                                                                                                                                    ))+ggtitle("Chr 15")+xlab("")+ylab("log2(Lamin fusion/Dam)")
```

```{r, echo = FALSE, eval = FALSE}
# this just shouldnt run in rmarkdwon as its too long and just run in 
# Ok lets see if the computer can handle actually segmentating the whole thing twice or is this
# a server problem...
segmentator <- function(df2){
    cna.object <- CNA(
      genomdat = df2$score,
      chrom    = df2$seqnames,
      maploc   = df2$mid,
      data.type= "logratio"
    )
    smoothed <- smooth.CNA(cna.object) # this does nothing since its already smooth i think

    seg.results <- segment(
      smoothed,
      weights = df2$width,
      verbose = 1
     )
    segments.df <- seg.results$output
    return(segments.df)
}

seg_r <- segmentator(df_act)
seg_a <- segmentator(df_rest)

saveRDS(list(seg_a,seg_r),"Segments_list.rds")
```


Exact overlaps for all Lads and all Nup62KO integrations

```{r, echo = FALSE}
# load in the above prepared segmented 
seg_list <- readRDS("Segments_list.rds")
seg_a <- seg_list[1]
seg_r <- seg_list[2]
seg_a <- as.data.table(seg_a)
seg_r <- as.data.table(seg_r)
rm(seg_list)

# Match LADS to genes until you get 18.6% of genes in lads,
# then apply same thinking to determining non lad-ness
# if it turns out the best approach isnt just a vertical line down the
# centre of the bimodal distribution
mart <- useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", host    = 'grch37.ensembl.org')
atts <- c("ensembl_gene_id", "chromosome_name", "start_position", 
          "end_position")
genes <- getBM(attributes = atts, mart = mart,filters = c("transcript_biotype"),
                                                values=c("protein_coding"))
genes <- as.data.table(genes)
chrnames <- paste0("chr",c(c(1:22),"X","Y"))
genes$chromosome_name <- paste0("chr",genes$chromosome_name)
genes <- genes[chromosome_name%in% chrnames,]
setkey(genes, chromosome_name,start_position,end_position )

# simply runnign with all genes gives us 

# calcualted thresholds
high_thresh_a <- quantile(seg_a$seg.mean, 0.575)          # top 5% signal
low_thresh_a  <- -2#quantile(seg_a$seg.mean, 0.05)  

high_thresh_r <- quantile(seg_r$seg.mean, 0.61)          # top 5% signal
low_thresh_r  <- -2#quantile(seg_r$seg.mean, 0.05)  

#Mark and filter by this thresholds
seg_a[,LAD:="Not classified"][seg.mean>=high_thresh_a,LAD:="LAD"][seg.mean<=low_thresh_a,LAD:="Not LAD"]

seg_r[,LAD:="Not classified"][seg.mean>=high_thresh_r,LAD:="LAD"][seg.mean<=low_thresh_r,LAD:="Not LAD"]

setkey(seg_a, chrom, loc.start, loc.end)
setkey(seg_r, chrom, loc.start, loc.end)

gcount <- length(unique(genes$ensembl_gene_id)) 
# theres about 63k genes, some overlap boundries of any lads we make so 
# im gonna go with any sort of overlapp and then see from there
test1 <- foverlaps(genes,seg_a)
num1 <- length(unique(test1[LAD=="LAD" & !is.na(ensembl_gene_id),]$ensembl_gene_id))
num1
num1/gcount*100

test2 <- foverlaps(genes,seg_r)
num2 <- length(unique(test2[LAD=="LAD" & !is.na(ensembl_gene_id),]$ensembl_gene_id))
num2
num2/gcount*100  # rough percentage of genes in lads

seg_a[,LAD_binary:=ifelse(LAD == "LAD","LAD","not LAD")][,type := "Activated"]
seg_r[,LAD_binary:=ifelse(LAD == "LAD","LAD","not LAD")][,type := "Resting"]

lads <- rbind(seg_a,seg_r)
rm(seg_a)
rm(seg_r)
```


Overlaps between Nup 62KO integrations and LADs
 
 
```{r,echo = FALSE}
#Load Nup data as well
nups <- read.csv("C:/Users/38598/Desktop/hivint/nup153/Nup_62_2/Nup_all_peaks_together.csv")
nups <- nups[,-1]
nups <- as.data.table(nups)
nups <- nups[!is.na(integration_start)]
# load the random integration data as well at some point
setkey(lads,chrom, loc.start,loc.end)
setkey(nups,chr_name,integration_start,integration_end)
# complete overlp here, no integrations land in the spaces without LAD data
over <- foverlaps(nups,lads)
# just making things clear
cos <- colnames(over)
cos[9] <- "LAD_celltype"
colnames(over) <- cos  

# jsut keep the same ones
over <- over[cellType == LAD_celltype,]

# Add randm matched controls
real_gr <- GRanges(seqnames = nups$chr_name,strand = nups$strand,
                                ranges = IRanges(start = nups$integration_start,              
                                                        end = nups$integration_end) )
pool <- createRandomRegions(nregions = length(real_gr),
                            genome = BSgenome.Hsapiens.UCSC.hg19)
# lets try both completely random controls, and matched for GC and chromosome etc.
# have to calculaet GC content for this
focal_seq <- getSeq(BSgenome.Hsapiens.UCSC.hg19, real_gr)
pool_seq  <- getSeq(BSgenome.Hsapiens.UCSC.hg19, pool)

# Compute GC proportion
        # without as numveric the ouput is a matrix, so thats why thats there
real_gr$GC <- as.numeric(letterFrequency(focal_seq, "GC", as.prob = TRUE))
pool$GC  <- as.numeric(letterFrequency(pool_seq,  "GC", as.prob = TRUE))

real_gr$chr<- seqnames(real_gr)
pool$chr <- seqnames(pool)

# commented out because it takes a while
#matched <- matchRanges(
#    focal = real_gr,
#    pool  = pool,
#    covar = ~ chr +GC,   # formula: match on chromosome and GC
#    method = "nearest",         # nearest matching
#    replace = TRUE
#)
#RMC_gc_chr <- matched(matched)
# not this doesent keep the width well, just center them as peaks
saveRDS(RMC_gc_chr,"RMC_covariate.rds")
RMC_gc_chr <- readRDS("RMC_covariate.rds")
# now the fulyy random ones:
RMC_rand <- randomizeRegions(real_gr,
                              genome = BSgenome.Hsapiens.UCSC.hg19,
                              allow.overlaps = FALSE)
# this does keep width for whatever raaason 

#and the old one
set.seed(1234)
sim_bed <- fread("C:/Users/38598/Desktop/hivint/Integrations3/STP_simulated_hg19.clean_R1.bed")
RMC_old <- sim_bed[sample(nrow(sim_bed), nrow(nups)), ]
rm(sim_bed)
# cool # now stick them together i guess


RMC_rand <- as.data.table(RMC_rand)
RMC_rand <- RMC_rand[,c(1,2,3)]
RMC_rand$rmc <- "rand"

RMC_gc_chr <- as.data.table(RMC_gc_chr)
RMC_gc_chr <- RMC_gc_chr[,c(1,2,3)]
RMC_gc_chr$rmc <- "covariate"

RMC_old <- RMC_old[,c(1,2,3)]
RMC_old$rmc <- "old"
colnames(RMC_old) <- colnames(RMC_rand)

RMC <- rbind(RMC_rand,RMC_old,RMC_gc_chr)
rm(RMC_rand,RMC_gc_chr,RMC_old)
# fix widths to 2
RMC <- as.data.table(RMC)
RMC[,start:=end-start%/%2][,end:=start+1]
RMC <- RMC[seqnames %in% chrnames,]
# itnersect with lads
setkey(RMC,seqnames,start,end)

RMC <- foverlaps(RMC,lads)
#not a complete overlap, 2% here drop out due to no lad data, small enough to ignore
RMC <- RMC[!is.na(loc.start),]
```

 Count and proportion plots with and without KO153

```{r,echo = FALSE}
# Initial simple graphs

# just the count (this is total, includes KO153)
ggplot(over[!group%in%c("Resting_mock","Activated_mock","Resting_KO153","Activated_KO153"),]
, aes(fill=LAD_binary, x=cellType)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.3) +
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

ggplot(over[!group%in%c("Resting_mock","Activated_mock"),]
, aes(fill=LAD_binary, x=group)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.3) +
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))


ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=LAD_binary, x=group)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.3) +
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

#Add proportion plots

ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=LAD_binary, x=group)) + 
  geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

ggplot(over[!group%in%c("Resting_mock","Activated_mock"),]
, aes(fill=LAD_binary, x=group)) + 
  geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All integrations vs LADs")+
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

```

Realtive insertion location plots for HIV integration within LADs.
Semm relatively uniform

```{r,echo = FALSE}
over[,rel_pos:= (integration_start - loc.start)/(loc.end-loc.start)]


ggplot(over[LAD =="LAD" & ! group %in%c("Resting_mock","Activated_mock","Resting_KO153","Activated_KO153")], 
aes(x = rel_pos, fill = group)) +
  geom_histogram(binwidth = 0.05, color = "white", boundary = 0) + # boundry deals with first bin artifacting
  scale_fill_brewer(palette="Blues", direction = 1)+
  labs(x = "Relative position inside LAD",
       y = "Insertion count",
       title = "Distribution of HIV KO62 insertions within LADS") +
  theme_minimal()


```

Non_genic vs genic inside and outside LADs

```{r}
ggplot(over[!group%in%c("Resting_mock","Activated_mock","Resting_KO153","Activated_KO153"),]
, aes(fill=LAD_binary, x=isGenic)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.3) +
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

ggplot(over[!group%in%c("Resting_mock","Activated_mock","Resting_KO153","Activated_KO153"),]
, aes(fill=LAD_binary, x=isGenic)) + 
  geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))


  # here add random matched controls into the mix, thus separating
```

Feature-anchored frequency plot? or whatever

```{r}

```

Violin plots of expression for genic integrations and LAD status
    Note this is only expression data from genes we have integrations in
```{r,echo = FALSE}
ggplot(over, aes(x = cellType, y = log2(variance_norm_counts+1),fill = LAD_binary)) +
  geom_violin(trim =T) +
    labs(x = "Group", y = "Expression(log2 var norm count)",
           title = "Expression distribution by group") +
             theme_minimal()


ggplot(over, aes(x = group, y = log2(variance_norm_counts+1),fill = group)) +
  geom_violin(trim =T) +
          labs(x = "Group", y = "Expression(log2 var norm count)",
                                   title = "Expression distribution by sample") + facet_wrap(~cellType, scales = "free")+
                                                   theme_minimal()+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))+
                                                                      scale_x_discrete(drop = TRUE)+
                                                                      scale_fill_brewer(palette="Blues", direction = 1)


ggplot(over, aes(x = group, y = log2(variance_norm_counts+1),fill = LAD_binary)) +
  geom_violin(trim =T) +
            labs(x = "Group", y = "Expression(log2 var norm count)",
                                               title = "Expression distribution by sample and LAD") + facet_wrap(~cellType, scales = "free")+
                       theme_minimal()+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))+
        scale_x_discrete(drop = TRUE)  +
         scale_fill_brewer(palette="Blues", direction = 1)                                                                
```

Comparison of all genes we have expression data for, by LAD/integration status

```{r, echo = FALSE}
# get all the expressioin data
normalized_counts <- read.csv("C:/Users/38598/Desktop/hivint/nup153/Nup_62_2/cd4ACTvsREST_VSTcounts.csv")

# good now we have all genes, intersect this with LADS and genic integrations
# First split by Act/Rest, then paste back together
normalized_counts <- as.data.table(normalized_counts)
normcounts2 <- normalized_counts
normalized_counts$type <- "Resting"
normcounts2$type <- "Activated"
normalized_counts$variance_norm_counts <- normalized_counts$resting
normcounts2$variance_norm_counts <- normcounts2$activated

# we also need  Non integration LADs. so we need to cross lads with genes again
lad_genes <- foverlaps(lads[LAD_binary == "LAD"],genes)

# count it all up
normalized_counts[,Integration:=ifelse(gene_name %in% nups[cellType =="Resting" & isGenic =="Genic",]$ensembl_gene_id,
                                      "Integration present","No integration")][,LAD_status:=ifelse(gene_name %in% lad_genes[type =="Resting" & LAD_binary =="LAD",]$ensembl_gene_id,"in LAD","not in LAD")]

normcounts2[,Integration:=ifelse(gene_name %in% nups[cellType =="Activated" & isGenic =="Genic",]$ensembl_gene_id,
                                      "Integration present","No integration")][,LAD_status:=ifelse(gene_name %in% lad_genes[type =="Activated" & LAD_binary =="LAD",]$ensembl_gene_id,"in LAD","not in LAD")]

norms <- rbind(normalized_counts,normcounts2)

ggplot(norms, aes(x = type, y = log2(variance_norm_counts+1),fill = LAD_status)) +
  geom_violin(trim =T) +
                labs(x = "Group", y = "Expression(log2 var norm count)",
                                                                             title = "Expression distribution") + facet_wrap(~Integration, scales = "free")+
                                                                                                                                                                 theme_minimal()+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))+
                                                                                                                                                                                                                                                             scale_x_discrete(drop = TRUE)  +
                                                                                                                                                                                                                                                                                                                                                                  scale_fill_brewer(palette="Blues", direction = 1)    
```


Genic unique and separate integrations


Generalized uniqueness (unique in certain base window, regardless of being in gene or not)

Heatmaps relative to rloops etc..


```{r}

```