---
title: "Lads"
output: pdf_document
---

```{r setup,echo=F, message=FALSE, warning=FALSE}
library(rtracklayer) # for loading .bw files
library(data.table)
library(ggplot2)
    library(gridExtra)
library(dplyr)
library(stats)
library(mixtools)  # jesus all this for bimodal middle estimation.....
library(DNAcopy)
library(GenomicRanges)
library(biomaRt)
library(nullranges)
library(regioneR)
library(Biostrings)
library(BSgenome.Hsapiens.UCSC.hg19)
```

## Comparison of Nup62KO integrations to Lads

```{r, echo = F}
#Load data
restbw <- import.bw("Jurkat Lamin DAmID RGSE94971_sq77.dpn_smooth_60_R.bw")
actbw <- import.bw("Jurkat Lamin Dam ID A GSE94971_sq77.dpn_smooth_60_A.bw")
df_rest <- as.data.frame(restbw)
df_act <- as.data.frame(actbw)

```

Note: DamID lads data is raw (only short outliers seem to be filtered out, with background left in). I re-called the peaks using the same method mentioned in the paper (circualar binary segmentation instead of the hidden markov model that I usally use provided by Maja).

```{r, echo = F}
bin = 0.5

pr <- ggplot(df_rest, aes(x=score))+ geom_histogram(binwidth = bin, alpha = 0.4)+theme_minimal()+ggtitle("Resting Lamin DamID scores")
   # geom_line(data = denr, aes(x = x, y = y *length(x) * bin),
   #         color = "blue")+
   # geom_vline(xintercept=midpoint, col = "red")#+
    #geom_vline(xintercept=r_min[36], col = "blue")
pa <- ggplot(df_act, aes(x=score))+ geom_histogram(binwidth = bin, alpha = 0.4)+theme_minimal()+ggtitle("Activated Lamin DamID scores")
    #geom_line(data = dena, aes(x = x, y *length(x) * bin),
    #        color = "blue")+
    #geom_vline(xintercept=midpoint2, col = "red")#+
    #geom_vline(xintercept=a_min[2], col = "blue")#+
    #geom_vline(xintercept=a_min[3], col = "orange")

grid.arrange(pa, pr, ncol=2)
```

```{r, echo = F}
# tunning the DNA copy method
df_act <- as.data.table(df_act)
df_rest <- as.data.table(df_rest)

df_act<- df_act%>%
      mutate(mid = (start + end) / 2)

df_rest<- df_rest%>%
      mutate(mid = (start + end) / 2)
df_act <- as.data.table(df_act)
df_rest <- as.data.table(df_rest)
df2 <- df_act[seqnames %in% c("chr15"),]%>%
      mutate(mid = (start + end) / 2)
cna.object <- CNA(
  genomdat = df2$score,
  chrom    = df2$seqnames,
  maploc   = df2$mid,
  data.type= "logratio"
)
smoothed <- smooth.CNA(cna.object) # this does nothing since its already smooth i think

seg.results <- segment(
  smoothed,
  weights = df2$width,
  verbose = 1
)
segments.df <- seg.results$output

# this should be a perfect segmentation: check for voerlaps just to be sure:
gr <- GRanges(
  seqnames = segments.df$chrom,
  ranges   = IRanges(start = segments.df$loc.start, end = segments.df$loc.end)
)

any(countOverlaps(gr, gr) > 1)  # yay no overlaps, so i guees any overlaps are visual bug/plot error


#thresholds
high_thresh <- quantile(segments.df$seg.mean, 0.575)          # top 5% signal
low_thresh  <- -2 #quantile(segments.df$seg.mean, 0.05)  
```

Example plot of score distribution on chromosomes and called LADs (by me).
Paper doesent state exact parameters used, I presumed defaults for the peak calling weighted by fragment width and then varied the threshold until I got 18,6% of genes (around 3700 in resting and activated) classifed as overlapping LADs as they have in the paper (for the numbers to match this have to be protein coding genes only. 
Additionaly they say its genes "within" LADs but the only way to get 18.6% and 3700 at the same time is to count any overlap between genes and LADs). I also marked segements with segemntation lower than -2 (meaning much higher Dam signal compared to Dam-fusion).

```{r,echo = FALSE}


dfg <- segments.df[segments.df$seg.mean >=high_thresh,]
dfb <- segments.df[segments.df$seg.mean <=low_thresh,]

ggplot(df2, aes(x = mid, y = 0, xend = mid, yend = score)) +
     geom_segment(color = "steelblue", alpha = 0.6) +
              # segemnts that ae def not LADS
                            geom_segment(
                                                   data = dfb,
                                                                                       aes(
                                                                                         x    = loc.start,
                                                                                           xend = loc.end,
                                                                                                     y    = - 4.3,     # lower the bar slightly
                                                                                                               yend = - 4.4      # same y for horizontal
                                                                                                                         ), color = "darkred"
                                                                                                                          )+
                                                                                                                           # probably lads?
                                                                                                                              geom_segment(
                                                                                                                                  data = dfg,
                                                                                                                                   aes(
                                                                                                                                     x  = loc.start,
                                                                                                                                     xend  = loc.end,
                                                                                                                                      y = -4.2,
                                                                                                                                      yend=-4.3),
                                                                                                                                       color = "green") +
                                                                                                                                        facet_wrap(~ seqnames, scales = "free_x") +
                                                                                                                                         labs(x = "Genomic coordinate (bp)", y = "Score") +
                                                                                                                                         theme_minimal()+
                                                                                                                                          geom_point(
                                                                                                                                          aes(x = Inf, y = Inf, color = "Raw score"),
                                                                                                                                          show.legend = TRUE
                                                                                                                                           ) +
                                                                                                                                           geom_point(
                                                                                                                                           aes(x = Inf, y = Inf, color = "LADs"),
                                                                                                                                           show.legend = TRUE
                                                                                                                                            ) +
                                                                                                                                             geom_point(
                                                                                                                                              aes(x = Inf, y = Inf, color = "Not LADs"),
                                                                                                                                              show.legend = TRUE
                                                                                                                                              ) +
                                                                                                                                               scale_color_manual(
                                                                                                                                                name   = "",
                                                                                                                                                 values = c(
                                                                                                                                                 "Raw score"     = "steelblue",
                                                                                                                                                  "LADs"  = "green",
                                                                                                                                                   "Not LADs" = "darkred"
                                                                                                                                                    ))+ggtitle("Chr 15")+xlab("")+ylab("log2(Lamin fusion/Dam)")
```

```{r, echo = FALSE, eval = FALSE}
# this just shouldnt run in rmarkdwon as its too long and just run in 
# Ok lets see if the computer can handle actually segmentating the whole thing twice or is this
# a server problem...
segmentator <- function(df2){
    cna.object <- CNA(
      genomdat = df2$score,
      chrom    = df2$seqnames,
      maploc   = df2$mid,
      data.type= "logratio"
    )
    smoothed <- smooth.CNA(cna.object) # this does nothing since its already smooth i think

    seg.results <- segment(
      smoothed,
      weights = df2$width,
      verbose = 1
     )
    segments.df <- seg.results$output
    return(segments.df)
}

seg_r <- segmentator(df_act)
seg_a <- segmentator(df_rest)

saveRDS(list(seg_a,seg_r),"Segments_list.rds")
```


Exact overlaps for all Lads and all Nup62KO integrations

```{r, echo = FALSE}
# load in the above prepared segmented 
seg_list <- readRDS("Segments_list.rds")
seg_a <- seg_list[1]
seg_r <- seg_list[2]
seg_a <- as.data.table(seg_a)
seg_r <- as.data.table(seg_r)
rm(seg_list)

# Match LADS to genes until you get 18.6% of genes in lads,
# then apply same thinking to determining non lad-ness
# if it turns out the best approach isnt just a vertical line down the
# centre of the bimodal distribution
mart <- useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", host    = 'grch37.ensembl.org')
atts <- c("ensembl_gene_id", "chromosome_name", "start_position", 
          "end_position")
genes <- getBM(attributes = atts, mart = mart,filters = c("transcript_biotype"),
                                                values=c("protein_coding"))
genes <- as.data.table(genes)
chrnames <- paste0("chr",c(c(1:22),"X","Y"))
genes$chromosome_name <- paste0("chr",genes$chromosome_name)
genes <- genes[chromosome_name%in% chrnames,]
setkey(genes, chromosome_name,start_position,end_position )

# simply runnign with all genes gives us 

# calcualted thresholds
high_thresh_a <- quantile(seg_a$seg.mean, 0.575)          # top 5% signal
low_thresh_a  <- -2#quantile(seg_a$seg.mean, 0.05)  

high_thresh_r <- quantile(seg_r$seg.mean, 0.61)          # top 5% signal
low_thresh_r  <- -2#quantile(seg_r$seg.mean, 0.05)  

#Mark and filter by this thresholds
seg_a[,LAD:="Not classified"][seg.mean>=high_thresh_a,LAD:="LAD"][seg.mean<=low_thresh_a,LAD:="Not LAD"]

seg_r[,LAD:="Not classified"][seg.mean>=high_thresh_r,LAD:="LAD"][seg.mean<=low_thresh_r,LAD:="Not LAD"]

setkey(seg_a, chrom, loc.start, loc.end)
setkey(seg_r, chrom, loc.start, loc.end)

gcount <- length(unique(genes$ensembl_gene_id)) 
# theres about 63k genes, some overlap boundries of any lads we make so 
# im gonna go with any sort of overlapp and then see from there
test1 <- foverlaps(genes,seg_a)
num1 <- length(unique(test1[LAD=="LAD" & !is.na(ensembl_gene_id),]$ensembl_gene_id))
num1
num1/gcount*100

test2 <- foverlaps(genes,seg_r)
num2 <- length(unique(test2[LAD=="LAD" & !is.na(ensembl_gene_id),]$ensembl_gene_id))
num2
num2/gcount*100  # rough percentage of genes in lads

seg_a[,LAD_binary:=ifelse(LAD == "LAD","LAD","not LAD")][,type := "Activated"]
seg_r[,LAD_binary:=ifelse(LAD == "LAD","LAD","not LAD")][,type := "Resting"]

lads <- rbind(seg_a,seg_r)
rm(seg_a)
rm(seg_r)
```


Overlaps between Nup 62KO integrations and LADs
 
 
```{r,echo = FALSE}
#Load Nup data as well
nups <- read.csv("C:/Users/38598/Desktop/hivint/nup153/Nup_62_2/Nup_all_peaks_together.csv")
nups <- nups[,-1]
nups <- as.data.table(nups)
nups <- nups[!is.na(integration_start)]
# load the random integration data as well at some point
setkey(lads,chrom, loc.start,loc.end)
setkey(nups,chr_name,integration_start,integration_end)
# complete overlp here, no integrations land in the spaces without LAD data
over <- foverlaps(nups,lads)
# just making things clear
cos <- colnames(over)
cos[9] <- "LAD_celltype"
colnames(over) <- cos  

# jsut keep the same ones
over <- over[cellType == LAD_celltype,]

# Add randm matched controls
real_gr <- GRanges(seqnames = nups$chr_name,strand = nups$strand,
                                ranges = IRanges(start = nups$integration_start,              
                                                        end = nups$integration_end) )
pool <- createRandomRegions(nregions = length(real_gr),
                            genome = BSgenome.Hsapiens.UCSC.hg19)
# lets try both completely random controls, and matched for GC and chromosome etc.
# have to calculaet GC content for this
focal_seq <- getSeq(BSgenome.Hsapiens.UCSC.hg19, real_gr)
pool_seq  <- getSeq(BSgenome.Hsapiens.UCSC.hg19, pool)

# Compute GC proportion
        # without as numveric the ouput is a matrix, so thats why thats there
real_gr$GC <- as.numeric(letterFrequency(focal_seq, "GC", as.prob = TRUE))
pool$GC  <- as.numeric(letterFrequency(pool_seq,  "GC", as.prob = TRUE))

real_gr$chr<- seqnames(real_gr)
pool$chr <- seqnames(pool)

# commented out because it takes a while
#matched <- matchRanges(
#    focal = real_gr,
#    pool  = pool,
#    covar = ~ chr +GC,   # formula: match on chromosome and GC
#    method = "nearest",         # nearest matching
#    replace = TRUE
#)
#RMC_gc_chr <- matched(matched)
# not this doesent keep the width well, just center them as peaks
set.seed(1234)
#saveRDS(RMC_gc_chr,"RMC_covariate.rds")
RMC_gc_chr <- readRDS("RMC_covariate.rds")
# now the fulyy random ones:
RMC_rand <- randomizeRegions(real_gr,
                              genome = BSgenome.Hsapiens.UCSC.hg19,
                              allow.overlaps = FALSE)
# this does keep width for whatever raaason 

#and the old one

sim_bed <- fread("C:/Users/38598/Desktop/hivint/Integrations3/STP_simulated_hg19.clean_R1.bed")
RMC_old <- sim_bed[sample(nrow(sim_bed), nrow(nups)), ]
rm(sim_bed)
# cool # now stick them together i guess


RMC_rand <- as.data.table(RMC_rand)
RMC_rand <- RMC_rand[,c(1,2,3)]
RMC_rand$rmc <- "rand"

RMC_gc_chr <- as.data.table(RMC_gc_chr)
RMC_gc_chr <- RMC_gc_chr[,c(1,2,3)]
RMC_gc_chr$rmc <- "covariate"

RMC_old <- RMC_old[,c(1,2,3)]
RMC_old$rmc <- "old"
colnames(RMC_old) <- colnames(RMC_rand)

RMC <- rbind(RMC_rand,RMC_old,RMC_gc_chr)
rm(RMC_rand,RMC_gc_chr,RMC_old)
# fix widths to 2
RMC <- as.data.table(RMC)
RMC[,start:=end-start%/%2][,end:=start+1]
RMC <- RMC[seqnames %in% chrnames,]
# itnersect with lads
setkey(RMC,seqnames,start,end)

RMC <- foverlaps(RMC,lads)
#not a complete overlap, 2% here drop out due to no lad data, small enough to ignore
RMC <- RMC[!is.na(loc.start),]

RMC[,type2:=paste0(type,"_RMC")]
RMC[,type3:=paste0(type,"_RMC_",rmc)]

```

 Count and proportion plots with and without KO153 / Random matched controls

```{r,echo = FALSE}
# Initial simple graphs

# just the count (this is total, includes KO153)
ggplot(over[!group%in%c("Resting_mock","Activated_mock","Resting_KO153","Activated_KO153"),]
, aes(fill=LAD_binary, x=cellType)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+
  geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.3,position = position_stack(reverse = TRUE,vjust = 1)) +
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

# same as above but with RMC
ggplot(over[!group%in%c("Resting_mock","Activated_mock","Resting_KO153","Activated_KO153"),]
, aes(fill=LAD_binary, x=cellType)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.3,position = position_stack(reverse = TRUE,vjust = 1)) +
  geom_bar(data = RMC, aes(x = type3, fill = LAD_binary), inherit.aes = F)+
   geom_text(data = RMC,stat = "count", aes(label = ..count..,x = type3, fill = LAD_binary), inherit.aes = F,vjust = -0.3,position = position_stack(reverse = TRUE,vjust = 1))+
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

# This one just to show KO153 is in the dataset
ggplot(over[!group%in%c("Resting_mock","Activated_mock"),]
, aes(fill=LAD_binary, x=group)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.3) +
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

# just KO62
ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=LAD_binary, x=group)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.3) +
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))
# add in the RMC here as well
ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=LAD_binary, x=group)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + 
      geom_bar(position = position_stack(reverse = TRUE),data = RMC, aes(x = type3, fill = LAD_binary), inherit.aes = F)+
            ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+geom_text(stat = "count", aes(label = ..count..),position = position_stack(reverse = TRUE,vjust = 1),
                              vjust = -0.3) +
                                  geom_text(data = RMC,stat = "count", aes(label = ..count..,x = type3, fill = LAD_binary), inherit.aes = F,position = position_stack(reverse = TRUE,vjust = 1),
                                                                  vjust = -0.3) +
                                                                                                    scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
                                                                                                                                        xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

#Add proportion plots

ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=LAD_binary, x=group)) + 
  geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),]
, aes(fill=LAD_binary, x=group)) + 
  geom_bar(position = "fill")+ 
    geom_bar(data = RMC, aes(x = type3, fill = LAD_binary), position = "fill")+
      theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+
        scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
          xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

# below are rations with KO153 included, not needed right now probably

#ggplot(over[!group%in%c("Resting_mock","Activated_mock"),]
#, aes(fill=LAD_binary, x=group)) + 
#  geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All integrations vs LADs")+
#  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
#  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

```

Realtive insertion location plots for HIV integration within LADs.
Seem relatively uniform, just covariate RMCs behaving weirdly at LAD start sites, which is expected due to GC content of LADs? (covariate RMCs are made to be similar to integration sites in GC content and chromosomal ratios).

```{r,echo = FALSE}
over[,rel_pos:= (integration_start - loc.start)/(loc.end-loc.start)]

ggplot(over[LAD =="LAD" & ! group %in%c("Resting_mock","Activated_mock","Resting_KO153","Activated_KO153")], 
aes(x = rel_pos, fill = group)) +
  geom_histogram(binwidth = 0.05, color = "white", boundary = 0) + # boundry deals with first bin artifacting
  scale_fill_brewer(palette="Blues", direction = 1)+
  labs(x = "Relative position inside LAD",
       y = "Insertion count",
       title = "Distribution of HIV KO62 insertions within LADS") +
  theme_minimal()

# do the sam for RMC
RMC[, rel_pos:=(start - loc.start)/(loc.end-loc.start)]

ggplot(RMC[LAD =="LAD"], 
aes(x = rel_pos, fill = type3)) +
  geom_histogram(binwidth = 0.05, color = "white", boundary = 0) + # boundry deals with first bin artifacting
    scale_fill_brewer(palette="Blues", direction = 1)+
      labs(x = "Relative position inside LAD",
             y = "Insertion count",
                    title = "Distribution of random controls within LADS") +
                      theme_minimal()
```

Non_genic vs genic inside and outside LADs

```{r}
# add genic status to RmC
RMC <- foverlaps(RMC,genes)
RMC[,isGenic:=ifelse(is.na(ensembl_gene_id),"Nongenic","Genic")]
RMC[,genic_split := paste0("RMC_",isGenic,"_",rmc)]
#counts
ggplot(over[!group%in%c("Resting_mock","Activated_mock","Resting_KO153","Activated_KO153"),]
, aes(fill=LAD_binary, x=isGenic)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+geom_text(stat = "count", aes(label = ..count..),
            vjust = -0.3) +
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

ggplot(over[!group%in%c("Resting_mock","Activated_mock","Resting_KO153","Activated_KO153"),]
, aes(fill=LAD_binary, x=isGenic)) + 
  geom_bar(position = position_stack(reverse = TRUE))+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+
      geom_text(stat = "count", aes(label = ..count..),
                        vjust = -0.3,position = position_stack(reverse = TRUE,vjust = 1)) +
    geom_bar(data = RMC, aes(x = genic_split, fill = LAD_binary),position = position_stack(reverse = TRUE))+ 
                                                                  geom_text(data = RMC,stat = "count", aes(label = ..count..,x = genic_split, fill = LAD_binary), inherit.aes = F,vjust = -0.3,position = position_stack(reverse = TRUE,vjust = 1))+
                                                                                          scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
                                                                                                                                   xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))

                                                    #proportions
ggplot(over[!group%in%c("Resting_mock","Activated_mock","Resting_KO153","Activated_KO153"),]
, aes(fill=LAD_binary, x=isGenic)) + 
  geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+
  scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
  xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))


  # here add random matched controls into the mix, thus separating

                                                      #proportions
ggplot(over[!group%in%c("Resting_mock","Activated_mock","Resting_KO153","Activated_KO153"),]
, aes(fill=LAD_binary, x=isGenic)) + 
  geom_bar(position = "fill")+ theme_minimal() + ylab("Number of integrations")+ggtitle("All KO62 integrations vs LADs")+
    geom_bar(data = RMC, aes(x = genic_split, fill = LAD_binary),position ="fill")+ 
      scale_fill_brewer(palette="Blues", direction = 1)+ theme(axis.ticks.y = element_blank())+
        xlab("")+ylab("")+ theme(axis.text.x = element_text(angle = 90, vjust = 0, hjust=0.5))
        
```

Feature-anchored frequency plot? or whatever

```{r}

```

Violin plots of expression for genic integrations and LAD status
    Note this is only expression data from genes we have integrations in
```{r,echo = FALSE}
ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),], aes(x = cellType, y = log2(variance_norm_counts+1),fill = LAD_binary)) +
  geom_violin(trim =T) +
    labs(x = "Group", y = "Expression(log2 var norm count)",
           title = "Expression distribution by LAD/Activation") +
             theme_minimal()+ scale_fill_brewer(palette="Blues", direction = 1)+theme(legend.title = element_blank())



ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),], aes(x = group, y = log2(variance_norm_counts+1),fill = group)) +
  geom_violin(trim =T) +
          labs(x = "Group", y = "Expression(log2 var norm count)",
                                   title = "Expression distribution by sample") + facet_wrap(~cellType, scales = "free")+
                    theme_minimal()+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))+
                           scale_x_discrete(drop = TRUE)+
               scale_fill_brewer(palette="Blues", direction = 1)+theme(legend.position = "none")

ggplot(over[!group%in%c("Resting_mock","Activated_mock"),], aes(x = group, y = log2(variance_norm_counts+1),fill = group)) +
  geom_violin(trim =T) +
          labs(x = "Group", y = "Expression(log2 var norm count)",
                                   title = "Expression distribution by sample") + facet_wrap(~cellType, scales = "free")+
                    theme_minimal()+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))+
                           scale_x_discrete(drop = TRUE)+
               scale_fill_brewer(palette="Blues", direction = 1)+theme(legend.position = "none")


ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),], aes(x = group, y = log2(variance_norm_counts+1),fill = LAD_binary)) +
  geom_violin(trim =T) +
            labs(x = "Group", y = "Expression(log2 var norm count)",
                                               title = "Expression distribution by sample and LAD") + facet_wrap(~cellType, scales = "free")+
                       theme_minimal()+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))+
        scale_x_discrete(drop = TRUE)  +
         scale_fill_brewer(palette="Blues", direction = 1)+theme(legend.title = element_blank()) 

#adding RMCs to this is lemon difficult
# have to cross it with all expression data and thats below
#  continued below after expression dataset load
```

Same as above but added RMCs (GC cov only for spacing reasons. Generally look the same)
If plot doesent separate experimental samples that means mock and KO153 are excluded:

```{r, echo = FALSE}
# get all the expressioin data
normalized_counts <- read.csv("C:/Users/38598/Desktop/hivint/nup153/Nup_62_2/cd4ACTvsREST_VSTcounts.csv")

# good now we have all genes, intersect this with LADS and genic integrations
# First split by Act/Rest, then paste back together
normalized_counts <- as.data.table(normalized_counts)
normcounts2 <- normalized_counts
normalized_counts$type <- "Resting"
normcounts2$type <- "Activated"
normalized_counts$variance_norm_counts <- normalized_counts$resting
normcounts2$variance_norm_counts <- normcounts2$activated

# we also need  Non integration LADs. so we need to cross lads with genes again
lad_genes <- foverlaps(lads[LAD_binary == "LAD"],genes)

# count it all up
normalized_counts[,Integration:=ifelse(gene_name %in% nups[cellType =="Resting" & isGenic =="Genic",]$ensembl_gene_id,
                                      "Integration present","No integration")][,LAD_status:=ifelse(gene_name %in% lad_genes[type =="Resting" & LAD_binary =="LAD",]$ensembl_gene_id,"in LAD","not in LAD")]

normcounts2[,Integration:=ifelse(gene_name %in% nups[cellType =="Activated" & isGenic =="Genic",]$ensembl_gene_id,
                                      "Integration present","No integration")][,LAD_status:=ifelse(gene_name %in% lad_genes[type =="Activated" & LAD_binary =="LAD",]$ensembl_gene_id,"in LAD","not in LAD")]

norms <- rbind(normalized_counts,normcounts2)

#Slam this into the RMC data
genic_RMC <- foverlaps(RMC,genes)
genic_RMC <- genic_RMC[!is.na(ensembl_gene_id),]

genic_RMC2 <- merge(genic_RMC, norms,by.x = c("ensembl_gene_id","type"),by.y =c("gene_name","type"))
#good that worked 

ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),], aes(x = cellType, y = log2(variance_norm_counts+1),fill = LAD_binary)) +
  geom_violin(trim =T, width= 0.7) +
              labs(x = "Group", y = "Expression(log2 var norm count)",
                                                             title = "Expression distribution by group plus RMCs") +
                                                                                                                      theme_minimal()+ scale_fill_brewer(palette="Blues", direction = 1)+
                                                                                                                                                                                    geom_violin(width = 0.7, data = genic_RMC2[type3 %in%c("Activated_RMC_covariate","Resting_RMC_covariate"),], aes(x = type2, y = log2(variance_norm_counts+1),fill = LAD_binary),trim = T)+theme(legend.title = element_blank())


genic_RMC2$cellType <- genic_RMC2$type # need equal names for faceting variable
ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),], aes(x = group, y = log2(variance_norm_counts+1),fill = group)) +
  geom_violin(trim =T,width = 0.5) +
    geom_violin(width = 0.5, data = genic_RMC2[type3 %in%c("Activated_RMC_covariate","Resting_RMC_covariate"),], aes(x = type2, y = log2(variance_norm_counts+1),fill = type2),trim = T)+
              labs(x = "Group", y = "Expression(log2 var norm count)",
                                                 title = "Expression distribution by sample") + facet_wrap(~cellType, scales = "free")+
                                                                     theme_minimal()+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))+
                                                                                                scale_x_discrete(drop = TRUE)+
                                                                                                               scale_fill_brewer(palette="Blues", direction = 1)+theme(legend.position = "none")


ggplot(over[!group%in%c("Resting_mock","Resting_KO153","Activated_mock","Activated_KO153"),], aes(x = group, y = log2(variance_norm_counts+1),fill = LAD_binary)) +
  geom_violin(trim =T) +
   geom_violin(width = 0.5, data = genic_RMC2[type3 %in%c("Activated_RMC_covariate","Resting_RMC_covariate"),], aes(x = type2, y = log2(variance_norm_counts+1),fill = LAD_binary),trim = T)+
            labs(x = "Group", y = "Expression(log2 var norm count)",
                                               title = "Expression distribution by sample and LAD") + facet_wrap(~cellType, scales = "free")+
                       theme_minimal()+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))+
        scale_x_discrete(drop = TRUE)  +
         scale_fill_brewer(palette="Blues", direction = 1)+theme(legend.title = element_blank()) 

```

Comparison of all genes we have expression data for, by LAD/integration status

```{r}
ggplot(norms, aes(x = type, y = log2(variance_norm_counts+1),fill = LAD_status)) +
  geom_violin(trim =T) +
                labs(x = "Group", y = "Expression(log2 var norm count)",
                                                                             title = "Expression distribution") + facet_wrap(~Integration, scales = "free")+
                                                                                                                                                                 theme_minimal()+ theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust=0.5))+
                                                                                                                                                                                                                                                             scale_x_discrete(drop = TRUE)  +
                                                                                                                                                                                                                                                                                                                                                                  scale_fill_brewer(palette="Blues", direction = 1)  
```

Genic unique and separate integrations


Generalized uniqueness (unique in certain base window, regardless of being in gene or not)

Heatmaps relative to rloops etc..


```{r}

```